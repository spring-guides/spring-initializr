:project-version: 1.0.0.BUILD-SNAPSHOT

= Using the Stubs

The Initializr project publishes
https://github.com/tomakehurst/wiremock[WireMock] stubs for all the
JSON responses that are tested in the project. If you are writing a
client for the Initializr service, you can use these stubs to test
your own code. You can consume them with the raw Wiremock APIs, or via
some features of
https://github.com/spring-cloud/spring-cloud-contract[Spring Cloud
Contract].

WireMock is an embedded web server that analyses incoming requests and
chooses stub responses based on matching some rules (e.g. a specific
header value). So if you send it a request which matches one of its
stubs, it will send you a response as if it was a real Initializr
service, and you can use that to do full stack integration testing of
your client.

== Using WireMock with Spring Boot

A convenient way to consume the stubs in your project is to add a test
dependency:

[source,xml,indent=0,subs="attributes,specialchars"]
----
		<dependency>
			<groupId>io.spring.initializr</groupId>
			<artifactId>initializr</artifactId>
			<classifier>stubs</classifier>
			<version>{project-version}</version>
			<scope>test</scope>
		</dependency>
----

and then pull the stubs from the classpath. In a Spring Boot
application, using Spring Cloud Contract, you can start a WireMock
server and register all the stubs with it like this:

[source,java,subs="attributes"]
----
@RunWith(SpringRunner.class)
@SpringBootTest
@AutoConfigureWireMock(port = 0, stubs="classpath:META-INF/io.spring.initializr/initializr/{project-version}")
public class ClientApplicationTests {

	@Value("${wiremock.server.port}")
	private int port;

    ...

}
----

Alternatively you can register individual stubs with the server by
autowiring it, and using its own API. For example:

[source,java,indent=0]
----
	
	@Value("classpath:META-INF/io.spring.initializr/initializr/{project-version}/mappings/metadataWithV2AcceptHeader.json")
	private Resource root;

	@Autowired
	private WireMockServer server;
	
	@Test
	public void testDependencies() throws IOException {
		server.addStubMapping(StubMapping.buildFrom(StreamUtils.copyToString(
				root.getInputStream(), Charset.forName("UTF-8"))));
        ...
	}

----

Then you have a server that returns the stub of the JSON metadata
("metadataWithV2AcceptHeader.json") when you send it a header "Accept:
application/vnd.initializr.v2+json" (as recommended).

NOTE: Spring Cloud Contract also has support for easily running stubs
of multiple services on different ports. You might find that useful if
your client uses other services. To just load up the Initializr stubs
in your test case you use `@AutoConfigureStubRunner` (instead of
`@AutoConfigureWireMock`)

== Names and Paths of Stubs

The stubs are laid out in a jar file in a form (under "/mappings")
that can be consumed by WireMock just by setting its file source. The
names of the individual stubs are the same as the method names of the
test cases that generated them in the Initializr project. So for
example there is a test case "metadataWithV2AcceptHeader" in
`MainControllerIntegrationTests` that makes assertions about the
response when the accept header is
"application/vnd.initializr.v2+json". The response is recorded in the
stub, and it will match in WireMock if the same headers and request
parameters that were used in the Initializr test case and used in the
client. The method name usually summarizes what those values are.